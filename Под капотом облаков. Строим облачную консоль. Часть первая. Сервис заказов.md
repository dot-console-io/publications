---
sticker: emoji//1f468-200d-1f4bb
color: 
banner:
---
Перед тем как начать описывать сам сервис, давайте рассмотрим основные типы объектов, вокруг которыз будем строить наш сервис

**Заказ(Order)** - поручение создать какой-то ресурс.

**Физический ресурс(PhysicalResource)** - Созданный объект в среде виртуализации или других внешних системах. Может быть виртуальной машиной, сетью, подсетью, диском, заявкой в jira, бакетом в s3 хранилищем или контейнеров в выделенном кластере kubernetes

**Логический ресурс(Resource)** - Артефакт который был создан в результате заказа или импортирован. Сам по себе представляет только запись в базе данных и содержит всю необходимую информацию о созданном **физическом ресурсе**. Обычно может олицетворять заказанную виртуальную машину, диск, сеть, СУБД и т.п. 

**Сценарий(Graph)** - последовательность действий, необходимое для выполнения заказа и в результате которого может создаваться один или несколько ресурсов. Пример сценария создания виртуальной машины: 
1. Cоздать сетевой интерфейс;
2. Cоздать загрузочный диск из образа;
3. Cоздать виртуальную машину с сетевым интерфейсом и диском созданными ранее;
4. Cоздать ресурсы на созданные объекты в среде виртуализации.

## Что такое заказ и его жизненный цикл

Как мы ранее и говорили, заказ это намерение создать какой, то ресурс. Так же в это понятие можно добавить и намерение изменить или удалить ресурс, так как с точки зрения консоли нет никакой разницы какой сценарий запускать - который приведет к созданию ресурса, его удалению или же изменения, например того-же объема диска в среде виртуализации. 

Если говорить, более укрупненно, то в заказ можно отнести любую асснихронную операцию, которую инициировал пользователь.

Рассмотрим как выглядит заказ в Azure. Выбра именно это облако, так как в нем более наглядно демонстрируется разделение объекта заказа и ресурсов

![[image.png|Рисунок 1. Заказ в Azure]]

А ниже представлен уже сформированный заказ со списком создаваемых ресурсов.

![[image 1.png|Рисунок 2. Сформированный заказ]]

Почему стараюсь разделить сущности заказа и ресурсов? Я видел на примере нескольких облаков, какие сложности в использовании и логическом объяснении вызывает подход, когда заказ и ресурс логически не разделеины. Даже если брать компоновку UI, то статус заказа и статус ресурса — разные вещи, и пытаться обработать это на фронте приводит к миллиону ненужных фильтров и сложности вывода табличного представления, когда одна рабочая ВМ смешивается с 10 неуспешными заказами.

Так же хочу обратить ваше внимание на стутс заказа. Тут я для себя выделяю 2 подхода к их организации
1. Сделать фиксированную статусную модель. Данных подход нам облегчит работу с ними и позволит не тратить ресурсы на дополнительную обработку разных статусных моделей, но приводит к тому, что пользователь может сидеть и час наблюдать заказ в статусе "создание"
2. Дать возможность настраивать статусную модель для каждого типа заказ. Идельным референсом тут выступает наша горяче любимая Jira. При таком подходе пользователь уже может наблюдать довольно динамичное изменение статусов при развертывании больших продуктов и даже есть возможность настроить progress бар. Но возникают сложности с фильтрацией заказов по статусу и дополнительные расходы на поддержку при низкой ценности итоговой фичи.

Для закрепления выше сказанного, ниже привел пример базовой статусной модели воображаемого заказа

![[1-8.png]]


И чтобы блок с описанием структуры заказа был закончен, опишу остальные свойства, которыми мы будем пользоваться:
1. **Имя заказа** - Вводимое пользователем, читаемое имя, из которого будет генерироваться имя для ресурсов
2. **Идентификатор** - уникальный идентификатор заказа в рамках всей консоли. Для упрощения будем использовать UUID v4
3. **Расположение** - указание где создан проект. Начиная от имени организации, заказнчивая проектом или приложением в проекте, если такой функциона лреализован
4. **Статус** - текущий статус заказа. Содержит как идентификатор, так и читаемое имя.
5. **Метаданные** - информация о том, кто и когда создал заказ
6. **Ссылки** - Массив ссылок на ресурсы, которые участововали в заказе
7. **Параметры заказа** - данные, с которыми был создан заказ. Передаются пользователем и могут обогащаться промежуточными сервисами
8. **История** - Список действий которые были произведены над заказом. Содержат информацию о действиях пользователя и изменении информации со стороны смежных микросервисов (например - изменение статуса оркестратором)

## Дизайн сервиса

В ходе рассуждения как же должен работать сервис заказов и каким образом эти заказы должны выполняться, мы сформировали список требований к сервису:

- **Распределенные транзакции и возможность их отката** - Выполнение сценариев связано с вызовом большого количества внешних компонентов, работа которых может быть продолжительной по времени. Но в данном пункет важны не столько распределенные транзакции, сколько возомжность их отката при ошибки на одном из этапов. Над этой темой мы порассуждаем в главе посвященной оркестратору, заботой которого и будет отслеживание этих транзакций.
- **Ассинхронность** - представьте, что вам нужно создать 100 виртуальных машин при помощи какого-нибудь инструмена IaC и первое с чем вы столкнетесь, что послежовательное и синхронное создание ресурсов заставит вас ждать несколько часов перед тем как вы сможете продолжить работу. Следовательно, чтобы избежать проблем, при поступлении заказа, должен сразу отдаваться его идентификатор, по которому можно получить статус ассинхронного заказа
- **Гибкое управление сценариями** - Так как одна из целей это создать удобный конструктор продуктов, следовательното хранениея сценариев в коде исключено. Должен быть компонент, который будет загружать из базы сценарий и контролировать его выполнение
- **Отслеживаемость** - Каждый заказ должен обладать актуальным статусом выполнения и иметь отслеживание хода выполнения в процентном представлении (как в DigitalOcean). Тут мы опять подходим к выбору статусной модели и для реализации отслеживаемости, мы выберем настраиваемую статусную модель для каждого типа заказа, при этом принимаю рисики и сложности реализации.
- **Атомарность** - заказ выполнился полностью или вообще не выполнился (можно этот пункт объединить с распределёнными транзакциями)

Если начать искать архитектурные решения, вбив в поиск первый пункт из вышеприведенного списка, то нам сразу выдаст информацию о таком паттерне, как SAGA, из которого мы и взяли такое понятие, как “Сервис заказов” и “Оркестратор”. Хотя сервис заказов сам по себе не является кникальным для этого паттерна и люди заказывали что-то и до появления SAGA, но именно то определение, которое приводится в описании паттерна, нам подходит больше всего.

Сам по себе паттерн SAGA, рассказывает нам о двух подходах выполнения ассинхронных операций:

- Хореография — действие в одном сервисе, приводит к публикации события для запуска действия в другом сервисе. Вся совокупность действией и составляет распределенную транзакцию
- Оркестрация — есть выделенный оркестратор, который публикует события для запуска транзакций в сервисах (то же, что и выше — не транзакция, а событие что ли)

![[1-9.png]]

Вызов распределенных согласно паттерну SAGA

к картинке выше: распределённых транзакций

Почему выбрали оркестрацию? В этом подходе я (так я или мы?) нашел для себя несколько плюсов:

- При добавлении нового компонента, не придется переписывать события в смежных
- Единая точка отслеживания хода выполнения заказа
- Реализация пПолучениея сценариев из БД, нужно реализовать только в одном месте
- Низкая связанность сервисов, которыей выполняют транзакции (они не знают о других модулях и не знают ни о каких сценариях и СУБД)

Дополнительно к этому мы отделили сервис заказаов от оркестратора, для гибкого масштабирования и удобства разработки.

![[1-1.png]]

События при публикации заказа

## Функционал

Выделим основной функционал нашего сервиса, который нам необходим в данный момент (будет дополняться по мере написания других частей)

![[1-10.png]]

- **Создание заказов** - сервис должен принимать объект с описанием заказа и сохранять его в БД. В ответ должен уходить идентификатор заказа по которому его можно будет найти
- **Получение списка заказов** - метод получения краткой информации по всем заказам, которые удволетворяют фильтрам
- **Получение детальной информации по заказу** - получение такой информации о входных параметрах, ходе выполнения, метаинформации и прочего
- **Получение событий о изменении заказа** - требуется для того, чтобы каждый раз не запрашивать статус, а открыть websocket и ждать информации об изхменении
- **Отмена заказов** - тема отдельного разговора, но каждый заказ я могу отменить и при этом запустиятся обратные транзакции согласно сценарию
- **Отправка заказов оркестратору** - процесс, который публикует события в брокера и топик который слушает оркестратор
- **Обновление статуса заказов** - процесс, который слушает топик брокера об изменении хода выполнения заказа и сохраняет обновления в БД
- **Проверка прав доступ** - сразу реализовывать не будем, так как еще отсутствует система IAM для назначения ролей пользователям

## Дизайн API

Перед тем как определить каким образом мы будем заказывать продукты в сервисе и как передавать параметры для заказов, давайте взглянем на популярных облачных провайдеров и постараемся быть приблизительно похожи на них

> [!important]  
> Добавить в провайдеры больше описания самого API  

### Azure

![[1-2.png]]

На основе приведенного примера из Azure не понятно, поступают ли заказы в один сервис, или за их API прячеутся разные сервисы заказов для каждого типа продуктов.

В первом1 варианте можно достигнуть унификации, и, судя по параметрам {subscriptionId} / {resourceGroupName}, провайдер не брезгует передавать параметры прямо в path, поэтому тип продукта (Microsoft.Compute) может быть таким же параметром, а не ключоем маршрутизации для API Gateway.

Во втором 2 варианте можно достигнуть более гибкой модели разработки продуктов в облаке, когда у провайдера есть выделенные команды разработки и нет задачи переиспользования наработок других команд. В этому случае разработчики строят свой набор микросервисов для управления продуктом. Для нашего случая это не совсем подходит, так как у нас нет цели повторять сервис заказов для каждого продукта, плюс+ как я говорил выше, создание продуктов будет доступно из конструктора, и в этому случае разработка дополнительных микросервисов не желательна, хоть и возможна

### GCP

![[b0eb6639-b8fc-4f60-a379-1bb346d19bb3.png]]

У Google намного интереснее. У них тип ресурса есть и в URL и в объекте самого ресурса в поле kind. И судя по [формату объекта](https://cloud.google.com/compute/docs/reference/rest/v1/instances/insert#request-body), который описывает ВМ, вполне вероятно, что созданием каждого продукта занимается отдельный микросервис со своей обвязкой и api gateway использует домен 3го уровня именно для маршрутизации запросов в нужный микросервис. Плохо это или хорошо говорить тут не уместно, видимо разработчики сочли такой путь более удобным,й или мы просто не правильно поняли как это работает под капотом

### DigitalOcean

![[24f0b57d-83ed-459d-92a0-00e08e25a6a4.png]]

Тут все еще проще. В отличиеи от ранее рассмотренных облаков, в запросах не указывается местоположение ресурса в проектах, и информацию они могут получить только из токена сервисной учетной записи, которая делает запрос. Учитывая, что запрос на создание ресурса может делать и пользователь через UI, выходит что у DigitalOcean имеется фасад для публичного API. На этом мы не останавливаемся и попробуем посмотреть как фронт формирует заказы.

Если рассматривать итоговый запрос с формы заказа, то запросы уходят на адрес [https://cloud.digitalocean.com/api/v1/droplets](https://cloud.digitalocean.com/api/v1/droplets) и в теле запроса ключеом в словаре является тип ресурса.

При заказе же сетевых ресурсов запросы улетают на эндпоинт [https://cloud.digitalocean.com/graphql](https://cloud.digitalocean.com/graphql) и в теле запроса содержат тип операции operationName: createVpc.

Рискну сделать вывод, что у данного облачного провайдера каждый продукт является отдельно разработанным набором микросервисов

### Alibaba

![[ea74b088-366f-4c81-bded-d9a0dafffccc.png]]

Тут останавливаться не будем. Склоняюсь к варианту, что тут на каждый тип ресурса разрабатывался отдельный набор микросервисов

### Российскией облака

![[884a174e-cd96-4ce8-af51-ce7a99c802c6.png]]

  

### Наш интерфейс

На основе примеров выше определим составляющие объекта заказа, который будет передаваться в сервис:

- **Тип** - для какого продукта предназначен заказ (Compute, PostgreSQL, Kubrnetes……)
- **Действие** - что требуется сделать в продукте (Create, Reboot, Delete, Resize)
- **Местоположение*** - если создается ресурс, требуется указать где его создать
- **Идентификатор*** - требуется если заказ изменяет ресурс
- **Параметры** **действия** - необходимые значения для выполнения действия

Так же стоит брать во внимание, что со временем потребуются операции, которые будут выполнятся не сервисом заказов, а отдельными микросервисами. Как пример: получение списка деплойментов из продукта kubernetes. При этом обращения могут быть напрямую в кластер и, соответсвенно, в этом кейсе не подойдет ассинхронная работа нашего сервиса заказов. Поэтому сразу стоит предусмотреть возможность маршуртизации на api gateway таких обращений

Выбранный вариант:

**[https://](https://onportal.io)****api.portal.loc/<имя_продукта>/<версия>/<тип ресурса>/<действие или метод>**

POST https://api.portal.loc/compute/v1/instance/create

Если нам придется проксировать некоторые действия в сторону от сервиса заказов, то реализовать мы можем это на основе поля версии. Например давайте выдумаем 3 действия, которые нам пригодятся для виртуальных машин:

- Создать - POST https://api.portal.loc/compute/**v1**/instance/create
- Перезагрузить - POST https://api.portal.loc/compute/**v1**/instance/myHost1/reboot
- Получить VNC - GET https://api.portal.loc/compute/**v1-1**/instance/myHost1/vnc

При этом схема будет выглядеть следующим образом:

![[1-11.png]]

Маршрутизация за контур сервиса заказа

Ну и в завершении давайте приведем пример сообщения на создание виртуальной машины

```JSON
{
	"name" : "hello-habr01",  //Уникальное имя ресурса
	"location" : {            //Местоположение ресурса в орг.структуре
		"project_id" : "myProj",
		"account" : "myPaymentAccount",
		"application" : "application-habr"
	},
	"spec" : {           //Параметры для создания ресурса
		"region" : "ru-msk",
		"zone" : "ru-msk-1",
		"flavor" : "b1ls",
		"network_ref" : {
			"uuid" : "2ab77373-33da-476a-9640-0f60555179e4",
			"name" : "myNetwork1"
		},
		"securitygroup_refs" : [
			{
				"uuid" : "2ab77373-33da-476a-9640-0f60555179e4",
				"name" : "default"
			},
			{
				"uuid" : "2ab77373-33da-476a-9640-0f60555179e4",
				"name" : "mySG1"
			}
		]
	}
}
```

В ответ будем ожидать следующую структуру

```JSON
{
	"name" : "hello-habr01",
	"uuid" : "2ab77373-33da-476a-9640-0f60555179e4" //Идентификатор заказа
	"location" : {
		"project_id" : "myProj",
		"account" : "myPaymentAccount",
		"application" : "application-habr"
	},
	"status" : { // Текущий статус
		"name" : "created",
		"progress" : 1
	},
	"metadata" : { // Информация о заказе
		"creator_ref" : {
			"uuid" : "2ab77373-33da-476a-9640-0f60555179e4",
			"name" : "username"
		},
		"date_created" : "2024-08-15T23:54:00.000+03:00"
	},
	"resource_refs" : [ // Ресурсы в заказе
		{
			"uuid" : "2ab77373-33da-476a-9640-0f60555179e4",
			"kind" : "network-interface"
			"name" : "hello-habr01-nic-2ab77373"
		},
		{
			"uuid" : "2ab77373-33da-476a-9640-0f60555179e4",
			"kind" : "volume"
			"name" : "hello-habr01-volume-2ab77373"
		},
		{
			"uuid" : "2ab77373-33da-476a-9640-0f60555179e4",
			"kind" : "instance"
			"name" : "hello-habr01"
		}
	]
	"spec" : { // Параметры заказа
		"region" : "ru-msk",
		"zone" : "ru-msk-1",
		"flavor" : "b1ls",
		"network_ref" : {
			"uuid" : "2ab77373-33da-476a-9640-0f60555179e4",
			"name" : "myNetwork1"
		},
		"securitygroup_refs" : [
			{
				"uuid" : "2ab77373-33da-476a-9640-0f60555179e4",
				"name" : "default"
			},
			{
				"uuid" : "2ab77373-33da-476a-9640-0f60555179e4",
				"name" : "mySG1"
			}
		]
	},
	"history" : [ // История заказа
		{
			"date" : "2024-08-15T23:54:00.000+03:00",
			"type" : "created"
			"label" : "Заказ создан",
			"actor" : {
				"uuid" : "2ab77373-33da-476a-9640-0f60555179e4",
				"name" : "username"
			},
			"content" : "<html></ntml>"
		},
		{
			"date" : "2024-08-15T23:54:00.000+03:00",
			"type" : "progress"
			"label" : "Заказ поступил на выполнение"
		},
		{
			"date" : "2024-08-15T23:54:00.000+03:00",
			"type" : "canceled"
			"label" : "Заказ отменен",
			"actor" : {
				"uuid" : "2ab77373-33da-476a-9640-0f60555179e4",
				"name" : "username"
			},
			"content" : "<html></ntml>"
		},
	]
}
```

## Обмен с внешними системам

Сервис заказов имеет как и синхронный интерфейс, с которым взаимодействие происходит через API Gateway, так и ассинхронный для публикации событий согласно паттерну SAGA в Apache Kafka.

Так же на схеме немного детализировал элементы

![[1-12.png]]

## В заключении

В этой статье описал ключевые аспекты работы сервиса заказа. В скором времени закончу писать пример сервиса и выложу исходный код на gitlab. Ссылка будет доступна в одной из следующих статей.

Все приведенные выше примеры не являются целевыми и будут меняться и дополняться с ходом развития темы данного цикла статей. Так же здесь мы не обсудили вопрос биллинга заказа, так как данную тему я вынесу в отдельную главу.